# chapter05

Start Date: May 25, 2022
Status: 객체지향프로그래밍

### week10

### 01 상속

1. 객체 지향의 상속
    1. 부모 클래스에 만들어진 필드, 메소드를 자식 클래스가 물려 받음
    2. 동일한 특성을 재정의할 필요가 없어 자식 클래스는 간결해진다.

---

### 02 객체 지향에서 상속의 장점

1. 클래스 간결화
    - 멤버 중복 작성 불필요
2. 클래스 관리 용이
    - 계층적 분류
3. 소프트웨어 생산성 향상
    - 클래스 재사용, 확장 용이
    - 새 클래스 작성 속도 빠름

---

### 03 클래스 상속과 객체

1. 자바 상속 선언

```java
public Person{...}
public class Student extends Person{...} //Person 클래스를 상속받는 Studnet 클래스
public class StudentWorker extends Student{...} //Studend 클래스를 상속받는 StudentWorder클래스
```

---

### 04 자바 상속의 특징

1. 다중상속 미지원
2. 상속 횟수 무제한
3. 상속의 최상위 조상 클래스: java.lang.Object
    1. 모든 클래스는 자동으로 java.lang.Object를 상속 받음
    2. 자바 컴파일러에 의해 자동으로 이루어짐
4. 상속과 접근 지정자 (소유 ≠ 접근)
    1. 접근 지정자 4가지: public / protected / 디폴트 / private
    2. 슈퍼 클래스의 private멤버
        - 다른 모든 클래스에 접근 불허
        - 클래스 내의 멤버들에게만 접근 허용
    3. 슈퍼 클래스의 protected멤버
        1. 같은 패키지 내의 모든 클래스 접근 허용
        2. 다른 패키지에 있더라도 서브 클래스는 슈퍼 클래스의 protected멤버에 접근 가능
    4. 슈퍼 클래스의 디폴트 멤버
        - 패키지 내 모든 클래스에 접근 허용
    5. 슈퍼 클래스의 publbic 멤버
        - 다른 모든 클래스에 접근 허용

---

### 05 서브 클래스 /슈퍼클래스의 생성자 호출 및 실행

1. 서브 클래스 객체가 생성될 때
    1. 서브 클래스 생성자와 슈퍼 클래스 생성자 모두 실행된다.
2. 실행순서
    1. 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자가 실행된다.
3. new에 의해 서브 클래스 객체 생성시
    1. 슈퍼 클래스, 생성자와 서브 클래스 생성자 모드 생성됨
    2. 호출순서
        - 서브 클래스 생성자 먼저 호출
        - 서브 클래스 생성자 실행 전 슈퍼 클래스 생성자 호출
    3. 실행 순서
        - 슈퍼 클래스 생성자 먼저 실행 → 서브 클래스 생성자 실행

---

### 06 상속 정리

1. 소유 ≠ 접근
2. field이름과 method 이름 중복 허용
    1. method ⇒method overriding (field overriding이란 말은 없음)
    2. field명이 겹칠 경우
    
    ```java
    public class A{ int x; f(){ ... } }
    public class B{ int x; f(){ ... } }
    public class C{ int x; f(){ ... } }
    
    //만일 C 클래스에서 x = 10;을 하면 C의 int x = 10;이 됨(this.x개념)
    //부모 클래스의 int x값을 변경하고 싶다면, super.x =10;을 사용해라
    //손자에서 조부모로 바로갈 순 없음. 부모를 거쳐서 가야함
    ```
    
3. 생성자의 호출과 실행의 순서
    1. 생성자 호출: C → B → A
    2. 생성자 실행: A → B → C
4. super.field명 사용시 주의사항
    1. 자식클래스 생성자에 부모 클래스 생성자를 호출하는 문장이 없다면? defalut
        - 만일 그게 아니면? 직접 고를 수 있음
    2. super.field는 첫 분장에 옴
        - 그러므로 this.field명과 동시에 나올 수 없음
        - 왜? 둘 다 첫 번째 행에 들어 가야 함

---

### 07 다형성 ⭐

1. 서브 클래스 객체
    1. 슈퍼 클래스의 멤버를 모두 가지고 있음
    2. 슈퍼 클래스의 객체로 취급할 수 있음
        - 사람은 생물이다의 논리와 같음
2. 업 캐스팅
    1. 객체 내에 슈퍼 클래스의 멤버만 접근 가능
    2. ⭐부모 타입 참조 변수로 하위 타입 객체를 가리킬 수 있다. ⭐무
        - 호출은 무조건 자식까지 호출된다.
    3. 업 캐스팅이 좋은 코드이다…
3. 다운 캐스팅
    1. 슈퍼 클래스 객체를 서브 클래스 타입으로 변환
    2. 개발자의 명시적 타입 변환 필요
    
    ```java
    class Person{ ... }
    class Student extends Person{ ... }
    ...
    Person p = new Student("이재문"); //업캐스팅
    /*p는 Person타입으로 Student와 Student의 부모(Person)를 상속 받음*/
    ...
    Student s = (Student)p; //다운캐스팅, (Student)의 타입 변환 표시 필요
    /*Student s = p하면 컴파일 에러가 나기 때문임
    왜? p가 업캐스팅일 수도 있지만 업캐스팅이 아닌 그냥 p만 가지고 있는 객체일 수도 있는 것임
    그러면 Student에 선언된 필드를 선언하면 오류가 날 것.
    강제형변환처럼 타입 변환을 하는 것 -> 컴파일은 통과됨 -> 실행시 문제될 수도 있음*/
    ```
    

---

### 08 instanceof 연산자와 객체의 타입 판단

1. 업 캐스팅 된 레퍼런스로 객체의 타입을 판단하기 어렵다.
    1. 이유: 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문
    2. 예시: ‘생물’이라는 팻말이 가리키는 박스에 들어있는 객체 타입이 사람인지, 동물인지는 팻말만 보고서 알 수 없음
2. instanceof 연산자
    1. 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용
    2. 사용 방법:  `객체레퍼런스 instanceof 클래스타입`
    3. 연산 결과: boolean값 (true 또는 false)
        - 상속 관계가 존재하면, 자식 타입부터 부모 타입까지 다양하게 가리킬 수 있음
        - 상황이 다양하므로, 진짜 가리키고 있는 객체가 무엇인지 알고 싶을 떄 instanceof 연산자를 사용함
    4. 좋은 코드: instancdof연산자를 안 쓰고 문제를 해결하는 것이다..

---

### 09 업 캐스팅 레퍼런스가 가리키는 객체(좋은 코드에 대한 고찰)

1. 다양한 타입이 넘어올 수 있다.

```java
//좋은코드
Person p = new Person();
Person p = new Student(); //업캐스팅
Person p = new Professor(); //업캐스팅
Person p = new Researcher(); //업캐스팅

void print(Person person){
	//person이 가리키는 객체는 Person타입일수도 있고,
	//Student, Professor, Reseracher타입일 수도 있음
}

//안좋은 코드: 클래스만큼 print를 만드는 것
//출력할 때마다 Student s = new Student();이런식으로 만듦
void print(Student student){...}
void print(Professor professor){...}
void print(Researcher researcher){...}
```

---

### 10 메소드 오버라이딩

- 객체지향의 핵심 개념:  메소드 오버라이딩 → 동적 바인딩 → 다형성, 바람직한 상속구조 활용
1. 슈퍼 클래스의 메소드를 서브 클래스에서 재정의함
    1. 슈퍼 클래스 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것 동일하게 작성
    2. 메소드 무시하기, 덮어쓰기로 번역 되기도 함
    3. 동적 바인딩이 발생함
        - 서브 클래스에서 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩
    4. 실생활 예
    
    ```java
    class Daddy{ //super class 
    	String laugh = "하하";
    	public Daddy(String laugh){
    	    this.laugh = laugh;
    	}
    } 
    
    class Baby extends Daddy{ // sub class, 기능: 아빠의 기능을 상속 받음
    	String cute; //확장된 기능
    	public Baby(String laugh){
    	    super(laugh);
    	}
    } 
    
    public class UpcastingEX{
    	public static void main(String[] args){
    		Daddy baby = new Baby("꺄르르");
    		System.out.println(baby.laugh);
    	}
    }
    ```
    
2. 오버라이딩에 의해 서브 클래스의 메소드 호출
    
    ```java
    Line line = new Line();
    line.draw(); //출력: Line
    
    Shape shape = new Line();
    shape.draw(); //출력: Line
    
    ```
    
    - 바인딩: 호출 대상과 호출물을 이어주는 것 (동적 바인딩: 런타임에서 생성됨↔정적 바인딩(컴파일 타임에서 생성됨)

---

### 11 오버라이딩의 목적과 다형성 실현

1. 오버라이딩: 수퍼 클래스에 선언된 method, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
2. 상속을 통해 하나의 인터페이스에 서로 다른 내용을 구현이라는 객체 지향의 다형성 실현
3. 오버라이딩은 실행시간 다형성 실현 (≠오버로딩)
    1. 동적바인딩을 통해 실행 중 다형성 실현
    2. 오버로딩은 컴파일 타임에 다형성 실현
4. 비교

| 요소 | 메소드 오버로딩 | 메소드 오버라이딩 |
| --- | --- | --- |
| 선언 | 같은 클래스나 상속관계에서 동일한 이름의 메소드 중복 작성 | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작성 |
| 관계 | 동일 클래스 내 혹은 상속 관계 | 상속 관계 |
| 목적 | 이름이 같은 여러 개의 메소드를 중복 작성해 사용의 편리성 향상, 다형성 실현 | 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의함, 다형성 실현 |
| 조건 | 메소드의 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 성립됨 | 메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일하여야 성립 |
| 바인딩 | Static, 호출 메소드는 컴파일 시 결정됨 | Dynamic, 호출 메소드는 런타임 시 결정됨 |

---

### 12 추상 메소드와 추상 클래스

1. 추상 메소드: 선언O이지만 구현X인 메소드, abstract로 선언
2. 추상 클래스 2종류
    1. 추상 메소드를 하나라도 가진 클래스
        
        ```java
        //1. 추상 메소드를 포함하는 추상 클래스
        Shape sahpe = new Shape(); //컴파일 오류! 이것만 안됨!!!
        //왜 오류일까? 추상 메소드의 동작이 정의가 안됐음.
        //객체를 생성하고 실행이되어야하는데... 뭘 동작할건지..?
        ```
        
    2. 추상 메소드는 하나도 없지만 abstract로 선언된 클래스
        
        ```java
        //2. 추상 메소드 없는 추상 클래스
        //클래스 자체가 추상 클래스니, 메모리상에 존재하지 않게 했음
        ```
        
    3. 주의점:  추상 클래스는 객체를 생성할 수 없음 →상속해서 쓰면 되긴 함?( 할튼간 교수님 맘에 안 드는 문장인 듯)
    
    ```java
    class A{
    	A(){...}
    	A(int A){...} //오버로딩
    }
    
    class B extends A{ //상속
    	B(int a){ super(A); } //가능
    }
    ```
    
3. 추상 클래스의 상속 2가지 경우
    1. 추상 클래스의 단순 상속
        - 추상 클래스를 상속 받아 추상 메소드를 구현하지 않으면? 추상클래스 됨
        - 서브 클래스도 abstract로 선언해야함
        
        ```java
        abstract class Shape{
        	public Shape(){ }
        	public void paint(){ draw(); }
        	abstract public void draw(); //추상 메소드, draw(){...;}가 아님! 구체적인 할일을 아직 안정해줌 
        }
        abstract class Line extends Shape{ //추상 클래스. 추상메소드 draw();를 상속받기 때문
        	public String toString(){return "Line";} 
        }
        ```
        
    2. 추상 클래스의 구현 상속
        - 서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
        - 서브 클래스는 추상 클래스 아님
    3. 추상 클래스의 용도
        - 설계와 구현의 분리
            - 슈퍼 클래스에서 개념 정의: 서브 클래스마다 다른 구현이 필요한 메소드는 추상 메소드로 선언
            - 각 서브 클래스에서 구체적 행위: 서브 클래스마다 목적에 맞게 추상 메소드 다르게 구현
        - 계층적 상속 관계를 갖는 클래스 구조 만들 때

---

### 13 자바의 인터페이스

1. 자바의 인터페이스: 클래스가 구현할 메소드들이 선언되는 추상형
2. 인터페이스 선언
    1. interface 키워드 선언 `public interface SerialDriver{…}`
3. 자바의 인터페이스에 대한 변화
    1. ~ Java7까지
        - 상수와 추상메소드로만 구성
    2. Java8이후 ~
        1. 상수와 추상메소드 포함
        2. default 메소드 포함(Java7)
        3. private, static메소드 포함(Java9)
    3. 단, 여전히 인터페이스에 필드(멤버 변수) 선언 불가
4. 강조
    1. 인터페이스를 구현하는 클래스는 언젠가 인터페이스의 추상메소드를 구현해야 한다.
5. 인터페이스 상속
    1. 인터페이스가 다른 인터페이스 상속
    2. case1
        - extends 사용
    3. case2
        - 다중 인터페이스 상속